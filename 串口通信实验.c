/**************************************************************************************
实验名称：串口通信实验
接线说明：	
实验现象：下载程序后，当串口助手发送数据给单片机，单片机原封不动转发给串口助手显示
注意事项：使用黄色跳线帽将CH340旁的P5端子的UTX和P30短接，URX和P31短接，出厂默认已短接好																				  
***************************************************************************************/

#include "reg52.h"  // 包含reg52.h头文件，用于声明51系列单片机的寄存器

typedef unsigned int u16;  // 重定义unsigned int为u16，提高代码可读性
typedef unsigned char u8;  // 重定义unsigned char为u8，提高代码可读性

/*******************************************************************************
* 函数名称       : uart_init
* 函数功能		 : 串口通信中断配置函数，通过设置TH和TL即可确定定时时间
* 输入       : baud：波特率对应的TH、TL装载值
* 输出    	 : 无
*******************************************************************************/
void uart_int(u8 baud)
{
    // 步骤1：设置计时器工作方式为串口通信
    TMOD |= 0x20;
    
    // 步骤2：配置串口通信模式
    SCON = 0x50;
    
    // 步骤3：启用波特率加倍以提高通信速率
    PCON = 0X80;
    
    // 步骤4：设置初始计时器值以确保波特率的准确性
    TH1 = baud;
    TL1 = baud;
    
    // 步骤5：启用串口中断和全局中断
    ES = 1;
    EA = 1;
    
    // 步骤6：启动计时器以开始串口通信
    TR1 = 1;
}

/*******************************************************************************
* 函数名称       : main
* 函数功能		 : 主函数
* 输入       : 无
* 输出    	 : 无
*******************************************************************************/
void main()
{
    // 初始化串口通信，设置波特率为9600
    uart_int(0xFA);
    
    // 进入无限循环，等待串口中断处理数据
    while(1)
    {
        // 无操作，仅等待中断
    }
}

/*******************************************************************************
* 函数名称       : uart
* 函数功能		 : 串口中断服务函数
* 输入       : 无
* 输出    	 : 无
*******************************************************************************/
void uart() interrupt 4
{
    u8 rec_data;
    
    // 步骤1：清除接收中断标志位
    RI = 0;
    
    // 步骤2：存储接收到的数据
    rec_data = SBUF;
    
    // 步骤3：将接收到的数据发送回去
    SBUF = rec_data;
    
    // 步骤4：等待发送数据完成
    while(!TI);
    
    // 步骤5：清除发送完成标志位
    TI = 0;
}
